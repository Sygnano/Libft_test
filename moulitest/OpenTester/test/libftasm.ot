%name       "libftasm"
%author     "Nax"
%identifier "OpenFT"
%desc       "The reference test suite for the assembly libft"

%match		"libfts.a"

%symbol		void	ft_bzero(void*, size_t)
%symbol		char*	ft_strcat(char*, char*)
%symbol 	int     ft_isalpha(int)
%symbol 	int     ft_isdigit(int)
%symbol 	int     ft_isalnum(int)
%symbol 	int     ft_isascii(int)
%symbol 	int     ft_isprint(int)
%symbol 	int     ft_toupper(int)
%symbol 	int     ft_tolower(int)
%symbol		int		ft_puts(const char*)
%symbol 	size_t  ft_strlen(char*)
%symbol		void*	ft_memset(void*, int, size_t)
%symbol     void*   ft_memcpy(void*, void*, int)
%symbol 	char*   ft_strdup(char*)
%symbol		void	ft_cat(int)


%test "ft_bzero" %{
    char    b1[42], b2[42];

    bzero(b1, 10);
    ft_bzero(b2, 10);
    assert_zero(memcmp(b1, b2, 10), "should zero a buffen of length 10");
    bzero(b1, 42);
    ft_bzero(b2, 42);
    assert_zero(memcmp(b1, b2, 42), "should zero a buffen of length 42");
    b1[0] = 1;
    ft_bzero(b1, 0);
    assert_equal(b1[0], 1, "should not write to buffer when length is 0");
%}

%test "ft_strcat" %{
    char    buf[9];

    bzero(buf, 9);
    ft_strcat(buf, "Bon");
    ft_strcat(buf, "jour.");
    ft_strcat(buf, "");
    assert_zero(strcmp(buf, "Bonjour."), "should concat multiple strings, including the empty string");
%}

%test "ft_isalpha" %{
    assert_true(ft_isalpha('a'), "should return true on 'a'");
    assert_false(ft_isalpha('a' + 0x100), "should return false on non ASCII");
    assert_false(ft_isalpha('2'), "should return false on '2'");
    assert_true(ft_isalpha('Z'), "should return true on 'Z'");
    assert_true(ft_isalpha('t'), "should return true on 't'");
%}

%test "ft_isdigit" %{
    assert_false(ft_isdigit(0), "should return false on NUL");
    assert_true(ft_isdigit('8'), "should return true on '8'");
    assert_false(ft_isdigit('8' + 0x100), "should return false on non-ASCII");
%}

%test "ft_isalnum" %{
    assert_false(ft_isalnum(' '), "should return false on space");
    assert_true(ft_isalnum('6'), "should return true on '6'");
    assert_true(ft_isalnum('Z'), "should return true on 'Z'");
    assert_false(ft_isalnum('5' + 0x100), "should return false on non-ASCII");
%}

%test "ft_isascii" %{
    assert_false(ft_isascii(200), "should return false on non-ASCII");
    assert_true(ft_isascii(0), "should return true on NUL");
    assert_true(ft_isascii(127), "should return true on DEL");
%}

%test "ft_isprint" %{
    assert_false(ft_isprint(0), "should return false on NUL");
    assert_false(ft_isprint(127), "should return false on DEL");
    assert_true(ft_isprint(' '), "should return true on space");
    assert_true(ft_isprint('a'), "should return true on 'a'");
    assert_true(ft_isprint('~'), "should return true on '~'");
%}

%test "ft_toupper" %{
    assert_equal(ft_toupper('a'), 'A', "should map 'a' to 'A'");
    assert_equal(ft_toupper(12345), 12345, "should map 12345 to 12345");
    assert_equal(ft_toupper(' '), ' ', "should map space to space");
    assert_equal(ft_toupper('Z'), 'Z', "should map 'Z' to 'Z'");
    assert_equal(ft_toupper('z'), 'Z', "should map 'z' to 'Z'");
%}

%test "ft_tolower" %{
    assert_equal(ft_tolower('T'), 't', "should map 'T' to 't'");
    assert_equal(ft_tolower(99999), 99999, "should map 99999 to 99999");
    assert_equal(ft_tolower('e'), 'e', "should map 'e' to 'e'");
    assert_equal(ft_tolower('Z'), 'z', "should map 'Z' to 'z'");
%}

%test "ft_puts" %{
    int     p[2];
    char    buf[4096];
	int		n;
    
    pipe(p);
    dup2(p[1], 1);
    ft_puts("aa");
    ft_puts(NULL);
	n = read(p[0], buf, 4095);
    buf[n] = 0;
    assert_zero(strcmp(buf, "aa\n(null)\n"), "should output to stdout");
    assert_more_or_equal(ft_puts("toto"), 0, "should return a nonnegative integer");
	close(1);
	assert_equal(ft_puts("hello"), -1, "should return EOF on error");
%}

%test "ft_strlen" %{
    assert_equal(ft_strlen("chat"), 4, "should return 4 on a string of length 4");
    assert_zero(ft_strlen(""), "should return zero on the empty string");
    assert_equal(ft_strlen("abcde"), 5, "should return 5 on a string of length 5");
%}

%test "ft_memset" %{
    char    b1[100], b2[100];

    ft_memset(b1, 42, 100);
    memset(b2, 42, 100);
    assert_equal(memset(b1, 99, 0), ft_memset(b1, 99, 0), "should return dst");
    assert_equal(memcmp(b1, b2, 100), 0, "should fill a buffer of length 100 with 42");
    b1[0] = 1;
    ft_memset(b1, 0, 0);
    assert_equal(b1[0], 1, "should not write to buffen when length is 0");
%}

%test "ft_memcpy" %{
    char    b1[10];
    char    b2[10] = {7, 42, 68, -44, 0, 6, 8, 9, 0, 77};

    ft_memcpy(b1, b2, 10);
    assert_equal(memcmp(b1, b2, 10), 0, "should copy a buffer of length 10");
    assert_equal(b1, ft_memcpy(b1, b2, 0), "should return dst");
%}

%test "ft_strdup" %{
    char    *c = "AbC";
    
    assert_zero(strcmp(ft_strdup("aaaaa"), "aaaaa"), "should return a string with the same content");
    assert_zero(strcmp(ft_strdup(""), ""), "should return an empty string when called on the empty string");
    assert_not_equal(c, ft_strdup(c), "should return a string with a different address");
    assert_zero(ft_strdup("abc")[4], "should return a NUL terminated string");
%}

%test "ft_cat" %{
    int     p[2];
    int     d[2];
    FILE*	f;
    int 	fd;
    const char data[] = "egiuweugfw\negwfuegufgue\n\n\newuewehufhufhuwefuhiwehiuwe\nefwefygwugfygyuweygugwegyfgyfwe\n\neijrgeigi";
    char buf[4096];
    int c;
    
    pipe(p);
    pipe(d);
    write(d[1], data, sizeof(data));
    close(d[1]);
    dup2(p[1], 1);
    ft_cat(d[0]);
    c = read(p[0], buf, 4096);
    buf[c] = 0;
    close(p[0]);
    close(p[1]);
    close(d[0]);
    assert_zero(strcmp(buf, data), "should output to stdout");
%}
